/* !
@file    glslshader.h
@author  louismineo.l@digipen.edu
@date    02/09/2022

This file contains definitions of member functions of class GLShader.
The member functions help to call for OpenGL's API to create the shader program
that will be invoked by the object. Theses functions range from compiling,
linking and validation of the shader program from its respective shader source,
logging of errors if the shader program does not work as intended,to the
setting of unifrom varibles into the shader files and the use of the Shader
Program to draw certain meshes or data from VBO.

*//*__________________________________________________________________________*/
#include "Graphics/glslshader.h"


/*!*****************************************************************************
\brief
    GetUniformLocation() is a getter function that returns the location of the 
    uniform variable
\param name
    name of the variable
\return
    intger value of the location of the variable in buffer
    - GL_INVALID_VALUE if the program is not a value generated by opengl
    - GL_INVALID_OPERATION if the program is not valid or not successfully linked.
*******************************************************************************/
GLint
GLSLShader::GetUniformLocation(GLchar const* name) 
{ 
    return glGetUniformLocation(pgm_handle, name);
}

/*!*****************************************************************************
\brief
    FileExists() checks if the file exists by checking if it is openable
\param file_name
    name of the file/ file path to the file
\return
    - GL_TRUE , if openable
    - GL_FALSE, if not able to be opened
*******************************************************************************/
GLboolean
GLSLShader::FileExists(std::string const& file_name) 
{
    std::ifstream infile(file_name);
    return infile.good();
}


/*!*****************************************************************************
\brief
    DeleteShaderProgram() deletes the shader_program object using 
    glDeleteProgram()
*******************************************************************************/
void
GLSLShader::DeleteShaderProgram() 
{
    if (pgm_handle > 0) 
    {
        glDeleteProgram(pgm_handle);
    }
}





/*!*****************************************************************************
\brief
    CompileLinkValidate() compiles the the individual shader sources and also 
    ensures that the multiple shader objects links into a executable shader 
    program.

    It opens the shader file via the full path to the file, and notes of its 
    corresponding shader program type: Vertex, Fragment, Geometry or Tessellation

    The information is retrieved from the 
    std::vector<std::pair<GLenum, std::string>> vec // FIRST PARAM

    For each shader file, CompileShaderFromFile() is called to link these shader
    files, then link() which will create the executable shader program.

    Lastly, it will call Validate() is ensure if the program is executable
    in the current OpenGL state.


\param	vec
    a vector of pairs containing the <shader program type , file path to the shader >
\return
    - GL_FALSE if linking fails
    - GL_FALSE if validation fails ( meaning the shader program is unable to 
        execute)
    - GL True if shader program is executable
*******************************************************************************/
GLboolean
GLSLShader::CompileLinkValidate(std::vector<std::pair<GLenum, std::string>> vec)
{
    //Compile both Vert and Frag shader code
    for (auto& elem : vec) 
    {
        if (GL_FALSE == CompileShaderFromFile(elem.first, elem.second.c_str()))
        {
            return GL_FALSE;
        }
    }

    if (GL_FALSE == Link())
    {
        return GL_FALSE;
    }
    if (GL_FALSE == Validate())
    {
        return GL_FALSE;
    }

    PrintActiveAttribs();
    PrintActiveUniforms();

    return GL_TRUE;
}

/*!*****************************************************************************
\brief
    CompileShaderFromFile() compiles the the individual shader files and also
    links the multiple shader objects into a executable shader program

    It loads the shader code from the file based from the file path, loads it 
    into the shader_file ifstream

    the string buffer, contains the text from the shader file

    It then compiles the buffer using CompilerShaderFromString

    Compilation statuses and messages are logged into the log_string

    If compilation is successful, the shader object is then attached to the
    previously created shader program object


\param	shader_type
    the is the shader type of the shader file (VERT, FRAG etc) 

\param	file_name
    the is the char* string to the shader file's path

\return
    - GL_FALSE if shader file is not found
    - GL_FALSE if shader file is unable to be opened
    - GL_FALSE if shader program is unable to be created
    - GL_TRUE or GL_FALSE depending on the response of CompileShaderFromString()
*******************************************************************************/


GLboolean
GLSLShader::CompileShaderFromFile(GLenum shader_type, const std::string& file_name) 
{
    if (GL_FALSE == FileExists(file_name)) 
    {
        log_string = "File not found";
        return GL_FALSE;
    }
    if (pgm_handle <= 0) 
    {
        pgm_handle = glCreateProgram();
        if (0 == pgm_handle) 
        {
            log_string = "Cannot create program handle";
            return GL_FALSE;
        }
    }

    std::ifstream shader_file(file_name, std::ifstream::in);
    if (!shader_file) 
    {
        log_string = "Error opening file " + file_name;
        return GL_FALSE;
    }
    std::stringstream buffer;
    buffer << shader_file.rdbuf();
    shader_file.close();
    return CompileShaderFromString(shader_type, buffer.str());
}



/*!*****************************************************************************
\brief
    CompileShaderFromString() first checks if there is an existing shader 
    program object, if not a new shader program is created using 
    glCreateProgram()

    It loads the shader code from the 2ND PARAM, shader_src

    the type of GLSLShader depends on the shader_type: 
    VERTEX SHADER, FRAGMENT SHADER, GEOMETRY SHADER, TESSELATION CONTROL
    or TESSELATION EVAULATION

    If an incorrect shader file type is parsed into the function, GL_FALSE is
    returned and the function 
    s.

    The function then uses glShaderSource and glCompileShader to compile
    the shader code

    Compilation status of the shader source is also logged using log_string.
    GL_FALSE is returned if compilation fails and the crash record is added into
    log_string which will be printed later.

    If compilation checks are all passed, the compiled shader code is attached
    to the newly-made or existing shader program and GL_TRUE is returned.


\param	shader_type
    the is the shader type of the shader file (VERT, FRAG etc)

\param	shader_src
    this is the shader code which will be compiled.

\return
    - GL_FALSE if shader program is unable to be created.
    - GL_FALSE if shader type is incorrect
    - GL_FALSE if shader code is unable to be compiled
    - GL_TRUE if the compiled shader code is successfully attached to a shader
        program
*******************************************************************************/
GLboolean
GLSLShader::CompileShaderFromString(GLenum shader_type,
    const std::string& shader_src) 
{
    if (pgm_handle <= 0) 
    {
        pgm_handle = glCreateProgram();
        
        if (0 == pgm_handle) {
            log_string = "Cannot create program handle";
            return GL_FALSE;
        }
    }

    GLuint shader_handle = 0;
    switch (shader_type) 
    {
    case VERTEX_SHADER: shader_handle = glCreateShader(GL_VERTEX_SHADER); break;
    case FRAGMENT_SHADER: shader_handle = glCreateShader(GL_FRAGMENT_SHADER); break;
    case GEOMETRY_SHADER: shader_handle = glCreateShader(GL_GEOMETRY_SHADER); break;
    case TESS_CONTROL_SHADER: shader_handle = glCreateShader(GL_TESS_CONTROL_SHADER); break;
    case TESS_EVALUATION_SHADER: shader_handle = glCreateShader(GL_TESS_EVALUATION_SHADER); break;
        //case COMPUTE_SHADER: shader_handle = glCreateShader(GL_COMPUTE_SHADER); break;
    default:
        log_string = "Incorrect shader type";
        return GL_FALSE;
    }

    // load shader source code into shader object
    GLchar const* shader_code[] = { shader_src.c_str() };
    glShaderSource(shader_handle, 1, shader_code, NULL);

    // compile the shader
    glCompileShader(shader_handle);

    // check compilation status
    GLint comp_result;
    glGetShaderiv(shader_handle, GL_COMPILE_STATUS, &comp_result);
    if (GL_FALSE == comp_result) 
    {

        log_string = "Vertex shader compilation failed\n";
        GLint log_len;
        glGetShaderiv(shader_handle, GL_INFO_LOG_LENGTH, &log_len);

        if (log_len > 0) 
        {
            GLchar* log = new GLchar[log_len];
            GLsizei written_log_len;
            glGetShaderInfoLog(shader_handle, log_len, &written_log_len, log);
            log_string += log;
            delete[] log;
        }
        return GL_FALSE;
    }
    else // attach the shader to the program object
    { 
        glAttachShader(pgm_handle, shader_handle);
        return GL_TRUE;
    }
}


/*!*****************************************************************************
\brief
    Link() will link the shader objects to the shader program by checking the 
    pgm_handle

    if the pgm_handle is invalid, Link() will return GL_FALSE;

    the shader program checked if it is linked using glGetProgramiv,
    if it returns 0, means that the shaderprogram is not successfully linked,
    reasons of linkage failed is logged into log_string and GL FALSE is RETURNED

    if linkage is successful, is_linked is flagged as TRUE and the function 
    returns GL_TRUE


\return
    - GL_TRUE if shader program is already linked
    - GL_FALSE if shader program's pgm_handle is invalid
    - GL_FALSE if the program tries to link the existing shader code and still
        is invalid
    - GL_TRUE if the program tries to link and is successful.
*******************************************************************************/
GLboolean GLSLShader::Link() 
{
    if (GL_TRUE == is_linked)
    {
        return GL_TRUE;
    }
    if (pgm_handle <= 0)
    {
        return GL_FALSE;
    }

    glLinkProgram(pgm_handle); // link the various compiled shaders

    // verify the link status
    GLint lnk_status;
    glGetProgramiv(pgm_handle, GL_LINK_STATUS, &lnk_status);

    if (GL_FALSE == lnk_status) 
    {
        log_string = "Failed to link shader program\n";
        GLint log_len;
        glGetProgramiv(pgm_handle, GL_INFO_LOG_LENGTH, &log_len);
        if (log_len > 0) 
        {
            GLchar* log_str = new GLchar[log_len];
            GLsizei written_log_len;
            glGetProgramInfoLog(pgm_handle, log_len, &written_log_len, log_str);
            log_string += log_str;
            delete[] log_str;
        }
        
        return GL_FALSE;
    }
    
    return is_linked = GL_TRUE;
}


/*!*****************************************************************************
\brief
    Use() will check if shader program is valid and linked successfully, and 
    then calls glUseProgram to execute the shader program
*******************************************************************************/
void GLSLShader::Use() 
{
    if (pgm_handle > 0 && is_linked == GL_TRUE) {
        glUseProgram(pgm_handle);
    }
}
/*!*****************************************************************************
\brief
    UnUse() will stop the execution of the shader program and uninstalls it
    by replacing it with glUseProgram(0).
*******************************************************************************/
void GLSLShader::UnUse() 
{
    glUseProgram(0);
}

/*!*****************************************************************************
\brief
    Validate() will check if the current shader program can execute in the 
    current OpenGL state.

    if shader program does not exist or is not linked
    GL_FALSE is returned.

    It utilises the openGL API's function, glValidateProgram to validate its 
    executability. 

    if validation fails, status is flagged false and its reasons are logged into
    log_string to be printed later.

    GL_TRUE is returned shader program passes validation.

return 
    - GL_FALSE if shader program is not linked or non-existent
    - GL_FALSE if shader program fails the validation check
    - GL_TRUE if the shader program passes the validation check
    
*******************************************************************************/
GLboolean GLSLShader::Validate() 
{
    if (pgm_handle <= 0 || is_linked == GL_FALSE) 
    {
        return GL_FALSE;
    }

    glValidateProgram(pgm_handle);
    GLint status;
    glGetProgramiv(pgm_handle, GL_VALIDATE_STATUS, &status);

    if (GL_FALSE == status) 
    {
        log_string = "Failed to validate shader program for current OpenGL context\n";
        GLint log_len;
        glGetProgramiv(pgm_handle, GL_INFO_LOG_LENGTH, &log_len);

        if (log_len > 0) 
        {
            GLchar* log_str = new GLchar[log_len];
            GLsizei written_log_len;
            glGetProgramInfoLog(pgm_handle, log_len, &written_log_len, log_str);
            log_string += log_str;
            delete[] log_str;
        }
        
        return GL_FALSE;
    }
    else
    {
        return GL_TRUE;
    }
}


/*!*****************************************************************************
\brief
    GetHandle() returns the handle of the shader program
\return
    GLuint value , depending on the OpenGL's API
*******************************************************************************/
GLuint GLSLShader::GetHandle() const 
{
    return pgm_handle;
}
/*!*****************************************************************************
\brief
    GetHandle() is a checker function which return the value of is_linked
\return
    GLboolean value of is_linked
*******************************************************************************/
GLboolean GLSLShader::IsLinked() const 
{
    return is_linked;
}
/*!*****************************************************************************
\brief
    GetLOG() will return the string from log_string, which can be used to print
    the logging information from the compilation, validation and linking 
    processes.
\return
    string of logging information from log_string
*******************************************************************************/
std::string GLSLShader::GetLog() const 
{
    return log_string;
}

/*!*****************************************************************************
\brief
    BindAttribLocation() utilises the OpenGL's API function 
    glBindAttribLocation() to dynamically associate a generic vertex attribute
    index with a named in attribute variable.
\param
    
\param index
    index of the vertex in location
\param name
    name to be binded to the index of the vertex
*******************************************************************************/
void GLSLShader::BindAttribLocation(GLuint index, GLchar const* name) 
{
    glBindAttribLocation(pgm_handle, index, name);
}

/*!*****************************************************************************
\brief
    BindFragDataLocation utilises the OpenGL's API function
    glBindFragDataLocation() to dynamically associate a fragment shader index
    location to a user-definted varible to write out to.
\param color_number
    color of the fragment
\param name
    name of variable to be binded to the specific fragment
*******************************************************************************/
void GLSLShader::BindFragDataLocation(GLuint color_number, GLchar const* name) 
{
    glBindFragDataLocation(pgm_handle, color_number, name);
}


/*!*****************************************************************************
\brief
    this SetUniform() function parses the value of a boolean variable into 
    into the shader program of the same variable name
\param name
    name of variable in shader program
\param val
    value of boolean variable
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, GLboolean val) 
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform1i(loc, val);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}

/*!*****************************************************************************
\brief
    this SetUniform() function parses the value of a integer variable into
    into the shader program of the same variable name
\param name
    name of variable in shader program
\param val
    value of integer variable
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, GLint val)
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform1i(loc, val);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}

/*!*****************************************************************************
\brief
    this SetUniform() function parses the value of a float variable into
    into the shader program of the same variable name
\param name
    name of variable in shader program
\param val
    value of float variable
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, GLfloat val) 
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform1f(loc, val);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}
/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of 2 float variable into
    into the shader program 's varible of name (1st param) and forms a vec2
    in the shader program
\param name
    name of variable in shader program
\param x
    value of the 1st element of the vec2
\param y
    value of the 2nd element of the vec2
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, GLfloat x, GLfloat y) 
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform2f(loc, x, y);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}

/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of 2 float variable into
    into the shader program 's varible of name (1st param) and forms a vec2
    in the shader program
\param name
    name of variable in shader program
\param x
    value of the 1st element of the vec3
\param y
    value of the 2nd element of the vec3
\param z
    value of the 3rd element of the vec3
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, GLfloat x, GLfloat y, GLfloat z)
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform3f(loc, x, y, z);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}


/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of 2 float variable into
    into the shader program 's varible of name (1st param) and forms a vec2
    in the shader program
\param name
    name of variable in shader program
\param x
    value of the 1st element of the vec3
\param y
    value of the 2nd element of the vec3
\param z
    value of the 3rd element of the vec3
\param w
    value of the 4th element of the vec3
*******************************************************************************/
void
GLSLShader::SetUniform(GLchar const* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) 
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform4f(loc, x, y, z, w);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}

/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of a glm vec2 into the shader 
    program 's varible of name (1st param) and forms a vec2 in the shader 
    program
\param name
    name of variable in shader program
\param val
    glm vec2 values to be parsed into
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, glm::vec2 const& val) 
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform2f(loc, val.x, val.y);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}
/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of a glm vec3 into the shader
    program 's varible of name (1st param) and forms a vec3 in the shader
    program
\param name
    name of variable in shader program
\param val
    glm vec3 values to be parsed into
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, glm::vec3 const& val)
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform3f(loc, val.x, val.y, val.z);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}
/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of a glm vec4 into the shader
    program 's varible of name (1st param) and forms a vec4 in the shader
    program
\param name
    name of variable in shader program
\param val
    glm vec4 values to be parsed into
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, glm::vec4 const& val) 
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniform4f(loc, val.x, val.y, val.z, val.w);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}
/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of a glm mat3 into the shader
    program 's varible of name (1st param) and forms a mat3 in the shader
    program
\param name
    name of variable in shader program
\param val
    glm mat3 values to be parsed into
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, glm::mat3 const& val)
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniformMatrix3fv(loc, 1, GL_FALSE, &val[0][0]);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}
/*!*****************************************************************************
\brief
    this SetUniform() function parses the values of a glm mat4 into the shader
    program 's varible of name (1st param) and forms a mat4 in the shader
    program
\param name
    name of variable in shader program
\param val
    glm mat4 values to be parsed into
*******************************************************************************/
void GLSLShader::SetUniform(GLchar const* name, glm::mat4 const& val) 
{
    GLint loc = glGetUniformLocation(pgm_handle, name);
    if (loc >= 0) 
    {
        glUniformMatrix4fv(loc, 1, GL_FALSE, &val[0][0]);
    }
    else 
    {
        std::cout << "Uniform variable " << name << " doesn't exist" << std::endl;
    }
}

/*!*****************************************************************************
\brief
    PrintActiveAttribs() prints the list of active vertex attributes used by
    the vertex shader
*******************************************************************************/

void GLSLShader::PrintActiveAttribs() const 
{
#if 1
    GLint max_length, num_attribs;
    glGetProgramiv(pgm_handle, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &max_length);
    glGetProgramiv(pgm_handle, GL_ACTIVE_ATTRIBUTES, &num_attribs);
    GLchar* pname = new GLchar[max_length];
    std::cout << "Index\t|\tName\n";
    std::cout << "----------------------------------------------------------------------\n";
    for (GLint i = 0; i < num_attribs; ++i) 
    {
        GLsizei written;
        GLint size;
        GLenum type;
        glGetActiveAttrib(pgm_handle, i, max_length, &written, &size, &type, pname);
        GLint loc = glGetAttribLocation(pgm_handle, pname);
        std::cout << loc << "\t\t" << pname << std::endl;
    }
    std::cout << "----------------------------------------------------------------------\n";
    delete[] pname;

#else
    GLint numAttribs;
    glGetProgramInterfaceiv(pgm_handle, GL_PROGRAM_INPUT, GL_ACTIVE_RESOURCES, &numAttribs);
    GLenum properties[] = { GL_NAME_LENGTH, GL_TYPE, GL_LOCATION };
    std::cout << "Active attributes:" << std::endl;
    for (GLint i = 0; i < numAttribs; ++i) {
        GLint results[3];
        glGetProgramResourceiv(pgm_handle, GL_PROGRAM_INPUT, i, 3, properties, 3, NULL, results);

        GLint nameBufSize = results[0] + 1;
        GLchar* pname = new GLchar[nameBufSize];
        glGetProgramResourceName(pgm_handle, GL_PROGRAM_INPUT, i, nameBufSize, NULL, pname);
        //   std::cout << results[2] << " " << pname << " " << getTypeString(results[1]) << std::endl;
        std::cout << results[2] << " " << pname << " " << results[1] << std::endl;
        delete[] pname;
    }
#endif
}

/*!*****************************************************************************
\brief
    PrintActiveUniforms prints the active uniform variables
*******************************************************************************/
void GLSLShader::PrintActiveUniforms() const 
{
    GLint max_length;
    glGetProgramiv(pgm_handle, GL_ACTIVE_UNIFORM_MAX_LENGTH, &max_length);
    GLchar* pname = new GLchar[max_length];
    GLint num_uniforms;
    glGetProgramiv(pgm_handle, GL_ACTIVE_UNIFORMS, &num_uniforms);
    std::cout << "Location\t|\tName\n";
    std::cout << "----------------------------------------------------------------------\n";
    for (GLint i = 0; i < num_uniforms; ++i) 
    {
        GLsizei written;
        GLint size;
        GLenum type;
        glGetActiveUniform(pgm_handle, i, max_length, &written, &size, &type, pname);
        GLint loc = glGetUniformLocation(pgm_handle, pname);
        std::cout << loc << "\t\t" << pname << std::endl;
    }
    std::cout << "----------------------------------------------------------------------\n";
    delete[] pname;
}
